name: Iaas ArgoCD Deploy Workflow

on:
  workflow_call:
    inputs:
      # æ ¸å¿ƒå¿…éœ€å‚æ•°
      environment:
        description: 'Target Environment'
        required: true
        type: string
      
      # å¯é€‰çš„ä¸šåŠ¡å‚æ•°
      argocd_sync:
        description: 'Trigger ArgoCD Sync'
        required: false
        type: boolean
        default: true
      argocd_timeout:
        description: 'ArgoCD sync timeout in seconds'
        required: false
        type: number
        default: 600
      
      # å¯é€‰çš„æ„å»ºå‚æ•°ï¼ˆå¦‚æœçœŸçš„éœ€è¦çµæ´»æ€§ï¼‰
      build_args:
        description: 'Docker build arguments (multiline string)'
        required: false
        type: string
        default: ''
    
    secrets:
      # æ³¨å†Œè¡¨è®¤è¯
      registry_username:
        description: 'Container registry username'
        required: true
      registry_password:
        description: 'Container registry password'
        required: true
      
      # ArgoCD è®¤è¯
      argocd_token:
        description: 'ArgoCD authentication token'
        required: true
      argocd_server:
        description: 'ArgoCD server URL'
        required: true
      
      # é€šçŸ¥
      slack_webhook_url:
        description: 'Slack webhook URL for notifications'
        required: false

# å›ºå®šçš„åº”ç”¨é…ç½®ï¼ˆåœ¨ common ä»“åº“ä¸­å®šä¹‰ï¼‰
env:
  # å›ºå®šé…ç½®
  REGISTRY: 'acr.gradient.network'
  NAMESPACE: ${{ inputs.environment }}
  # å›ºå®šçš„è·¯å¾„é…ç½®
  HELM_VALUES: helm/${{ inputs.environment }}-values.yaml
  DOCKERFILE_PATH: ./docker/dashboard.Dockerfile
  HELM_IMAGE_TAG_PATH: .system.imageTag
  # å›ºå®šçš„åº”ç”¨é…ç½®
  IMAGE_NAME: iaas-dashboard
  NAME: iaas-dashboard
  # å›ºå®šçš„ Git é…ç½®
  GIT_USER_EMAIL: 'ci@company.com'
  GIT_USER_NAME: 'CI Bot'
  # å›ºå®šçš„æ„å»ºé…ç½®
  BUILD_PLATFORMS: 'linux/amd64'

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
      simple_tag: ${{ steps.simple-tag.outputs.tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.registry_username }}
        password: ${{ secrets.registry_password }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=${{ github.ref_name }}.{{date 'YYYYMMDDTHHMMSS'}}.{{sha}}
        flavor: |
          latest=false

    - name: Extract simple tag
      id: simple-tag
      run: |
        FULL_TAG="${{ steps.meta.outputs.tags }}"
        SIMPLE_TAG=$(echo "$FULL_TAG" | sed 's|.*:||')
        echo "tag=$SIMPLE_TAG" >> $GITHUB_OUTPUT
        echo "Extracted simple tag: $SIMPLE_TAG"
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/dashboard.Dockerfile
        platforms: linux/amd64 
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          ENV=${{ inputs.environment || 'test' }}
          ${{ inputs.build_args }}

  update-values:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: ${{ !startsWith(github.ref, 'refs/tags/') }}
    permissions:
      contents: write    
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.github_token || secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Update Helm values
      env:
        NEW_TAG: ${{ needs.build-and-push.outputs.simple_tag }}
      run: |
        # å®‰è£… yq
        sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
        sudo chmod +x /usr/local/bin/yq
        
        cp "${{ env.HELM_VALUES }}" "${{ env.HELM_VALUES }}.backup"
        
        # ä½¿ç”¨å›ºå®šçš„ imageTag è·¯å¾„
        yq eval '${{ env.HELM_IMAGE_TAG_PATH }} = "'${NEW_TAG}'"' -i "${{ env.HELM_VALUES }}"
        
        # éªŒè¯æ›´æ”¹
        if grep -q "${NEW_TAG}" "${{ env.HELM_VALUES }}"; then
          echo "âœ… Successfully updated imageTag to ${NEW_TAG}"
        else
          echo "âŒ Failed to update imageTag"
          exit 1
        fi
        
        # æäº¤æ›´æ”¹
        git config user.email "${{ env.GIT_USER_EMAIL }}"
        git config user.name "${{ env.GIT_USER_NAME }}"
        git add "${{ env.HELM_VALUES }}"
        
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "chore(ci): update ${{ inputs.environment }} image tag to ${NEW_TAG}"
          git push
        fi

  trigger-argocd:
    needs: [build-and-push, update-values]
    runs-on: ubuntu-latest
    if: ${{ inputs.argocd_sync }}
    
    steps:
    - name: Install ArgoCD CLI
      run: |
        curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
        rm argocd-linux-amd64
        argocd version --client
    
    - name: Trigger ArgoCD Application Sync
      env:
        ARGOCD_TOKEN: ${{ secrets.argocd_token }}
        ARGOCD_SERVER: ${{ secrets.argocd_server }}
        APP_NAME: ${{ inputs.environment }}-${{ env.NAME }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.simple_tag }}
        BRANCH: ${{ github.ref_name }}
        ARGOCD_PARAMETER: "grpc-web"
      run: |
        # éªŒè¯è¿æ¥
        argocd app list --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER --$ARGOCD_PARAMETER | head -5
        
        # æ£€æŸ¥åº”ç”¨æ˜¯å¦å­˜åœ¨
        if ! argocd app get $APP_NAME --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER --$ARGOCD_PARAMETER > /dev/null 2>&1; then
          echo "âŒ ArgoCD application $APP_NAME not found"
          exit 1
        fi
        
        # è®¾ç½®åº”ç”¨ç‰ˆæœ¬
        echo "ğŸ”„ Setting application revision to $BRANCH"
        argocd app set $APP_NAME --revision $BRANCH --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER --$ARGOCD_PARAMETER
        
        # åŒæ­¥åº”ç”¨
        echo "ğŸš€ Syncing application $APP_NAME"
        argocd app sync $APP_NAME --prune --force --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER --$ARGOCD_PARAMETER
        
        # ç­‰å¾…åŒæ­¥å®Œæˆ
        echo "â³ Waiting for sync to complete (timeout: ${{ inputs.argocd_timeout }} seconds)"
        argocd app wait $APP_NAME --timeout ${{ inputs.argocd_timeout }} --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER --$ARGOCD_PARAMETER
        
        echo "âœ… ArgoCD application $APP_NAME synced successfully"

  notify:
    needs: [build-and-push, trigger-argocd]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify deployment status
      env:
        WEBHOOK_URL: ${{ secrets.slack_webhook_url }}
        STATUS: ${{ needs.trigger-argocd.result }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.simple_tag }}
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        # æ„å»ºè¯¦ç»†çš„çŠ¶æ€ä¿¡æ¯
        BUILD_STATUS="${{ needs.build-and-push.result }}"
        ARGOCD_STATUS="${{ needs.trigger-argocd.result }}"
        
        if [ "$STATUS" = "success" ]; then
          EMOJI="âœ…"
          STATUS_TEXT="deployment successful"
        elif [ "$STATUS" = "failure" ]; then
          EMOJI="âŒ"
          STATUS_TEXT="deployment failed"
        elif [ "$STATUS" = "cancelled" ]; then
          EMOJI="â¹ï¸"
          STATUS_TEXT="deployment cancelled"
        else
          EMOJI="âš ï¸"
          STATUS_TEXT="deployment status unknown"
        fi
        
        MESSAGE="$EMOJI ${{ env.IMAGE_NAME }} $STATUS_TEXT\n"
        MESSAGE="${MESSAGE}ğŸ“¦ Image: $IMAGE_TAG\n"
        MESSAGE="${MESSAGE}ğŸŒ Environment: $ENVIRONMENT\n"
        MESSAGE="${MESSAGE}ğŸ”¨ Build: $BUILD_STATUS\n"
        MESSAGE="${MESSAGE}ğŸš€ ArgoCD: $ARGOCD_STATUS\n"
        MESSAGE="${MESSAGE}ğŸ”— Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        if [ -n "$WEBHOOK_URL" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\"}" \
            "$WEBHOOK_URL"
        else
          echo "âš ï¸ SLACK_WEBHOOK_URL not configured, skipping notification"
        fi